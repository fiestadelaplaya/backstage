-- Migration: Initial Schema for Backstage Access Control System
-- Created: 2026-01-11
-- Description: Sets up tables for users, groups, controllers, activity, and restrictions

-- ============================================================================
-- ENUMS
-- ============================================================================

-- Role enum for user access levels
CREATE TYPE "public"."role" AS ENUM (
    'A',
    'B',
    'C',
    'D',
    'E',
    'P',
    'X',
    'X - TEC',
    'C - COM'
);

-- Gate enum for different access points
CREATE TYPE "public"."gate" AS ENUM (
    'S1',
    'S2',
    'S3',
    'S4'
);

-- ============================================================================
-- TABLES
-- ============================================================================

-- Groups table
CREATE TABLE IF NOT EXISTS "public"."groups" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1
        INCREMENT BY 1
        NO MINVALUE
        NO MAXVALUE
        CACHE 1
    ),
    "name" character varying NOT NULL,
    CONSTRAINT "groups_pkey" PRIMARY KEY ("id")
);

-- Users table
CREATE TABLE IF NOT EXISTS "public"."users" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1
        INCREMENT BY 1
        NO MINVALUE
        NO MAXVALUE
        CACHE 1
    ),
    "name" character varying NOT NULL,
    "lastname" character varying NOT NULL,
    "dni" integer UNIQUE NOT NULL,
    "role" "public"."role" NOT NULL,
    "group_id" bigint,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT now() NOT NULL,
    "enabled" boolean DEFAULT true NOT NULL,
    CONSTRAINT "users_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "users_group_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."groups"("id") ON DELETE SET NULL
);

-- Controllers table (for Google Sign In authentication)
CREATE TABLE IF NOT EXISTS "public"."controllers" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1
        INCREMENT BY 1
        NO MINVALUE
        NO MAXVALUE
        CACHE 1
    ),
    "email" character varying NOT NULL,
    "user_id" bigint,
    "gate" "public"."gate" NOT NULL,
    CONSTRAINT "controllers_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "controllers_email_key" UNIQUE ("email"),
    CONSTRAINT "controllers_user_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE SET NULL
);

-- Activity table (logs all access attempts)
CREATE TABLE IF NOT EXISTS "public"."activity" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1
        INCREMENT BY 1
        NO MINVALUE
        NO MAXVALUE
        CACHE 1
    ),
    "user_id" bigint NOT NULL,
    "timestamp" timestamp with time zone DEFAULT now() NOT NULL,
    "gate" "public"."gate" NOT NULL,
    CONSTRAINT "activity_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "activity_user_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE
);

-- Restrictions table (date-based access restrictions for groups)
CREATE TABLE IF NOT EXISTS "public"."restrictions" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1
        INCREMENT BY 1
        NO MINVALUE
        NO MAXVALUE
        CACHE 1
    ),
    "group_id" bigint NOT NULL,
    "date" date NOT NULL,
    CONSTRAINT "restrictions_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "restrictions_group_fkey" FOREIGN KEY ("group_id") REFERENCES "public"."groups"("id") ON DELETE CASCADE,
    CONSTRAINT "restrictions_unique_group_date" UNIQUE ("group_id", "date")
);

-- ============================================================================
-- INDEXES
-- ============================================================================

-- Index for faster user lookups by DNI
CREATE INDEX IF NOT EXISTS "users_dni_idx" ON "public"."users" ("dni");

-- Index for faster controller lookups by email
CREATE INDEX IF NOT EXISTS "controllers_email_idx" ON "public"."controllers" ("email");

-- Index for faster activity queries by user
CREATE INDEX IF NOT EXISTS "activity_user_id_idx" ON "public"."activity" ("user_id");

-- Index for faster activity queries by timestamp
CREATE INDEX IF NOT EXISTS "activity_timestamp_idx" ON "public"."activity" ("timestamp");

-- Index for faster restriction lookups by group and date
CREATE INDEX IF NOT EXISTS "restrictions_group_date_idx" ON "public"."restrictions" ("group_id", "date");

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Note: created_at is automatically set on INSERT via DEFAULT now() - no trigger needed
-- The DEFAULT clause handles the automatic setup of created_at when inserting new rows

-- Function to update updated_at timestamp on UPDATE operations
CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-update updated_at on users table when a row is updated
CREATE TRIGGER "update_users_updated_at"
    BEFORE UPDATE ON "public"."users"
    FOR EACH ROW
    EXECUTE FUNCTION "public"."update_updated_at_column"();

-- Optional: Trigger to prevent created_at from being modified after initial insert
-- This is a safeguard to ensure created_at remains immutable
CREATE OR REPLACE FUNCTION "public"."protect_created_at_column"()
RETURNS TRIGGER AS $$
BEGIN
    -- If created_at is being changed, revert it to the original value
    IF OLD.created_at IS DISTINCT FROM NEW.created_at THEN
        NEW.created_at = OLD.created_at;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to protect created_at from being modified
CREATE TRIGGER "protect_users_created_at"
    BEFORE UPDATE ON "public"."users"
    FOR EACH ROW
    EXECUTE FUNCTION "public"."protect_created_at_column"();

-- ============================================================================
-- ACCESS CONTROL FUNCTION
-- ============================================================================

-- Function to check access permissions and log activity atomically
-- Returns: JSON with success (boolean), message (string), and activity_id (bigint if successful)
CREATE OR REPLACE FUNCTION "public"."check_and_log_access"(
    p_user_id bigint,
    p_gate "public"."gate",
    p_controller_id bigint DEFAULT NULL
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_record RECORD;
    v_has_restriction boolean;
    v_restriction_date date;
    v_activity_id bigint;
BEGIN
    -- Check if user exists and is enabled
    SELECT u.*
    INTO v_user_record
    FROM "public"."users" u
    WHERE u.id = p_user_id;

    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'message', 'User not found',
            'activity_id', NULL
        );
    END IF;

    IF NOT v_user_record.enabled THEN
        RETURN jsonb_build_object(
            'success', false,
            'message', 'User is not enabled',
            'activity_id', NULL
        );
    END IF;

    -- Check role permissions
    -- X role has access to all gates
    IF v_user_record.role = 'X' THEN
        -- Skip role check
    ELSIF p_gate IN ('S1', 'S2') THEN
        -- S1 and S2: all roles have access
        -- No check needed
    ELSIF p_gate = 'S3' THEN
        -- S3: Only B and A roles
        IF v_user_record.role NOT IN ('A', 'B') THEN
            RETURN jsonb_build_object(
                'success', false,
                'message', 'User role does not have access to this gate',
                'activity_id', NULL
            );
        END IF;
    ELSIF p_gate = 'S4' THEN
        -- S4: Only A roles
        IF v_user_record.role != 'A' THEN
            RETURN jsonb_build_object(
                'success', false,
                'message', 'User role does not have access to this gate',
                'activity_id', NULL
            );
        END IF;
    END IF;

    -- Check group restrictions if user belongs to a group
    IF v_user_record.group_id IS NOT NULL THEN
        -- Get current date (timezone-aware)
        v_restriction_date := CURRENT_DATE;
        
        -- Check if the group has any restrictions at all
        IF EXISTS(
            SELECT 1
            FROM "public"."restrictions"
            WHERE group_id = v_user_record.group_id
        ) THEN
            -- Group has restrictions, user can only access on restricted dates
            -- Check if today's date is in the allowed dates
            SELECT EXISTS(
                SELECT 1
                FROM "public"."restrictions"
                WHERE group_id = v_user_record.group_id
                AND date = v_restriction_date
            ) INTO v_has_restriction;

            IF NOT v_has_restriction THEN
                RETURN jsonb_build_object(
                    'success', false,
                    'message', 'User group has restrictions and today is not an allowed date',
                    'activity_id', NULL
                );
            END IF;
        END IF;
        -- If group has no restrictions, user can access freely (do nothing)
    END IF;

    -- All checks passed, log activity
    INSERT INTO "public"."activity" ("user_id", "gate", "timestamp")
    VALUES (p_user_id, p_gate, now())
    RETURNING id INTO v_activity_id;

    RETURN jsonb_build_object(
        'success', true,
        'message', 'Access granted',
        'activity_id', v_activity_id
    );
END;
$$;

-- ============================================================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."groups" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."controllers" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."activity" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."restrictions" ENABLE ROW LEVEL SECURITY;

-- Policies for authenticated users (controllers)
-- Controllers can read users (to scan QR codes and validate access)
CREATE POLICY "controllers_read_users" ON "public"."users"
    FOR SELECT
    TO authenticated
    USING (true);

-- Controllers can read their own controller record
CREATE POLICY "controllers_read_own" ON "public"."controllers"
    FOR SELECT
    TO authenticated
    USING (auth.jwt() ->> 'email' = email);

-- Controllers can read all controllers (for reference)
CREATE POLICY "controllers_read_all" ON "public"."controllers"
    FOR SELECT
    TO authenticated
    USING (true);

-- Controllers can read groups (to check restrictions)
CREATE POLICY "controllers_read_groups" ON "public"."groups"
    FOR SELECT
    TO authenticated
    USING (true);

-- Controllers can read restrictions (to validate access)
CREATE POLICY "controllers_read_restrictions" ON "public"."restrictions"
    FOR SELECT
    TO authenticated
    USING (true);

-- Controllers can insert activity (via the function, but we need insert policy)
CREATE POLICY "controllers_insert_activity" ON "public"."activity"
    FOR INSERT
    TO authenticated
    WITH CHECK (true);

-- Controllers can read activity (their own gate's activity)
CREATE POLICY "controllers_read_activity" ON "public"."activity"
    FOR SELECT
    TO authenticated
    USING (true);

-- Note: The check_and_log_access function uses SECURITY DEFINER to bypass RLS
-- when inserting activity records, so the insert policy above may not be strictly
-- necessary, but it's good to have for explicit insert operations if needed.

